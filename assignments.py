# -*- coding: utf-8 -*-
"""Assignments.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ER1EC8Vnt3UnqwdOauG5hh48lzOeLIQK
"""

# numpy case study

# 1
import numpy as np
a =np.array([[5,5,5],[5,5,5],[5,5,5]])

print(a)

#2

import numpy as np
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])
c = np.array([[9, 10], [11, 12]])
sum_array=a+b+c
print('addition:\n',sum_array)

#3
import numpy as np

def top_left_sub_matrix(matrix, N, M):
    return matrix[:N, :M]
matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

result = top_left_sub_matrix(matrix, 2, 2)
print(result)

#4
import numpy as np

def sub_matrix(matrix, N, M):
    return matrix[-N:, -M:]
matrix = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

result = sub_matrix(matrix, 2, 2)
print(result)

#5
import numpy as np

def solution(arr):
    return {
        'mean': float(np.mean(arr)),
        'std_dev': float(np.std(arr))
    }
arr = np.array([1, 1, 1])
result = solution(arr)
print(result)

# numpy assignment-- data stucture

#1
# Create the initial list
myList = [10, 20, 30, 'apple', True, 8.10]

# a. Append values 30 and 40
myList.append(30)
myList.append(40)

# b. Reverse the list and store it in 'reversedList'
reversedList = myList[::-1]

#2

# Create the initial dictionary
my_dict = {
    1: 'data',
    2: 'information',
    3: 'text'
}

# a. Eliminate the 'text' value (key = 3)
my_dict.pop(3)

# b. Add 'features' to the dictionary (let's add it with a new key, e.g., 4)
my_dict[4] = 'features'

# c. Fetch the 'data' element from the dictionary
data_value = my_dict[1]
print(data_value)

#3

my_tuple = (1, 2, 3, 'apple', 'mango')

#4


numeric_tuple = (10, 20, 30, 40, 50)

# a. Find the minimum value
min_value = min(numeric_tuple)

# Assuming my_tuple is already defined as:
my_tuple = (1, 2, 3, 'apple', 'mango')

# b. Concatenate my_tuple with numeric_tuple
r1 = my_tuple + numeric_tuple

# c. Duplicate my_tuple 2 times
newdupli = my_tuple * 2
print("Duplicated tuple (newdupli):", newdupli)

#5

set1 = {1, 2, 3, 4, 5}
set2 = {2, 3, 7, 6, 1}

# a. Union of set1 and set2
union_result = set1.union(set2)
print("Union:", union_result)

# b. Intersection of set1 and set2
intersection_result = set1.intersection(set2)
print("Intersection:", intersection_result)

# c. Difference of set1 from set2 (elements in set1 not in set2)
difference_result = set1.difference(set2)
print("Difference:", difference_result)

# pandas assignment

import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
file_path ='/content/drive/My Drive/Colab Notebooks/dataset/customer_churn-pandas assignment - 1 .csv'
# Load the CSV file into a DataFrame
churn = pd.read_csv(file_path)

# Display the first few rows to confirm it's loaded correctly
churn.head()

#2

# Select columns by index positions (Python uses zero-based indexing)
newCols = churn.iloc[:, [2, 6, 8, 19]]

# Display the first few rows of the new DataFrame
newCols.head()

#3

# Select rows from index 200 to 1000 (inclusive)
subset_rows = churn.iloc[200:1001, :]

# Display the first few rows of the result
subset_rows.head()

#4

# Select rows from index 200 to 1000 (inclusive)
subset_rows = churn.iloc[200:1001, :]

# Display the first few rows of the result
subset_rows.head()

#5

# Display the top 100 records
churn.head(100)

#6

# Display the last record
churn.tail(1)

#7

# Sort the DataFrame by 'tenure' in descending order
sorted_churn = churn.sort_values(by='tenure', ascending=False)

# Display the top few rows to confirm
sorted_churn.head()

#8

# a. Tenure > 50 and Gender == 'Female'
condition_a = churn[(churn['tenure'] > 50) & (churn['gender'] == 'Female')]
print("Condition A:\n", condition_a.head())

# b. Gender == 'Male' and SeniorCitizen == 0
condition_b = churn[(churn['gender'] == 'Male') & (churn['SeniorCitizen'] == 0)]
print("\nCondition B:\n", condition_b.head())

# c. TechSupport == 'Yes' and Churn == 'No'
condition_c = churn[(churn['TechSupport'] == 'Yes') & (churn['Churn'] == 'No')]
print("\nCondition C:\n", condition_c.head())

# d. Contract == 'Month-to-month' and Churn == 'Yes'
condition_d = churn[(churn['Contract'] == 'Month-to-month') & (churn['Churn'] == 'Yes')]
print("\nCondition D:\n", condition_d.head())

#9

count = 0

# Iterate through each row using iterrows()
for index, row in churn.iterrows():
    if (row['gender'] == 'Male' and
        row['SeniorCitizen'] == 1 and
        row['TechSupport'] == 'Yes'):
        count += 1

print("Number of male senior citizens with tech support:", count)

# oops assignment 1
#1
def factor(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError("Input must be a non-negative integer.")
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
print(factor(5))

#2

def check_string(user_input):
    if 's' in user_input or 'S' in user_input:
        print("The string is containing the letter ‘s’")
    else:
        print("The string doesn’t contain the letter ‘s’")
check_string("Sunrise")
check_string("Moon")

#3

class student:
    def fun1(self):
        self.user_input = input("Enter a value: ")
        return self.user_input

    def message(self):
        print(f"The user-defined input is: {self.user_input}")
s = student()
s.fun1()
s.message()

#4

double_num = lambda x: x * 2
print(double_num(50))
print(double_num(15))

#5


user_input = input("Enter a string: ")

# Remove spaces and convert to lowercase for accurate comparison
cleaned_input = user_input.replace(" ", "").lower()

if cleaned_input == cleaned_input[::-1]:
    print("The string is a palindrome.")
else:
    print("The string is not a palindrome.")

# oops assignment 2
#1
class Super:
    def fun1(self):
        print("This is function 1 in the Super class.")
obj = Super()
obj.fun1()

#2
#2a
class Super:
    def fun1(self):
        print("This is function 1 in the Super class.")

class Modified_Super(Super):
    def fun1(self):
        print("This is function 1 in the Modified Super class.")

obj1 = Super()
obj1.fun1()

obj2 = Modified_Super()
obj2.fun1()

#2b
class Modified_Super(Super):
    def fun2(self):
        print("This is the 2nd function from the Modified Super class.")
obj = Modified_Super()
obj.fun1()
obj.fun2()

#2c

class Super:
    def fun1(self):
        print("This is function 1 in the Super class.")

class Modified_Super(Super):
    pass
obj = Modified_Super()
obj.fun1()

#3


class Demo:
    def Hello(self, arg1, arg2=None):
        if arg2 is None:
            print("This function is only having 1 argument")
        else:
            print("This function is having 2 arguments")
obj = Demo()
obj.Hello("one")
obj.Hello("one", "two")

#4

def Sum():
    user_input = input("Enter numbers separated by spaces: ")
    numbers = [int(num) for num in user_input.split()]

    total = 0
    for num in numbers:
        total += num

    return total
result = Sum()
print("The sum is:", result)

#5

class Encapsulation:
    def __init__(self):
        self.originalValue = 50  # Initialize variable in constructor

    def Value(self):
        return self.originalValue  # Return the initialized variable
obj = Encapsulation()
print(obj.Value())

# oops assignment 3

#1

class parent_Class:
    num = 10

class child_Class(parent_Class):
    pass

#  object of child_Class
obj = child_Class()
print(obj.num)

#2


class A:
    def __init__(self):
        self.name = "saisha"
        self.age = 25

    def details(self):
        return self.name

class B:
    def __init__(self):
        self.name = "vaishu"
        self.id = 101

    def details(self):
        return self.name

class C(A, B):
    def __init__(self):
        A.__init__(self)  # Explicitly calling A's constructor

    def get_details(self):
        return self.name

# Create object of class C
obj = C()
print(obj.get_details())

#3


class Sub1:
    def first(self):
        print("This is the first function from Sub 1 class")

class Sub2:
    def second(self):
        print("This is the second function from the Sub 2 class")

class Super(Sub1, Sub2):
    def final(self):
        print("This is the final method from the super class")

# Create an object of the Super class
obj = Super()
obj.first()
obj.second()
obj.final()

#4

class car:
    def fun1(self):
        print("This is the message from the fun1")

class bike:
    def fun2(self):
        print("This is the message from the fun2")

class scooty(car):
    def fun3(self):
        print("This is the message from the fun3")

# Create an object of Child2
obj = scooty()
obj.fun1()

#5

class Parent:
    def fun1(self):
        print("This is the message from the fun1")

class Child:
    def fun2(self):
        print("This is the message from the fun2")

class Hybrid(Parent, Child):
    def fun3(self):
        print("This is the message from the fun3")

# an object of Hybrid
obj = Hybrid()

obj.fun1()
obj.fun2()
obj.fun3()